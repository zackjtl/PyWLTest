import pattern
import random
import logging
import os

from test_gui import TestStatus
import test_gui

def debug_info_en():
	logging.basicConfig(level=logging.INFO)


class MyRand:
	def __init__(self):
		pass
		
	def seed(self, Seed):
		logging.info('Reset random seed: ' + str(Seed))
		random.seed(Seed)
	
	def randrange(self, a, b):
		logging.info('Rand range ' + str(a) + ' - ' + str(b) )
		return random.randrange(a, b)
		

class SeqRW:
	""" Sequential Read Write Test 
		
	Repeatly write, read and delete files into the disk. 
	All files will be deleted between each test cycles.
		
	"""		
	
	def __init__(self, DiskVolume='', TestParams={}):		
		self.global_written_sectors = 0
		self.written_sectors = 0
		self.folder_name = 0
		self.file_names = []
		self.DiskVolume=DiskVolume
		self.TestParams = TestParams
		self.Rand = MyRand()
		
		if ('MinSectorCnt' not in TestParams):
			self.TestParams['MinSectorCnt'] = 5
		if ('MaxSectorCnt' not in TestParams):
			self.TestParams['MaxSectorCnt'] = 10
		if ('CheckLastError' not in TestParams):
			self.TestParams['CheckLastError'] = False
		if ('TargetSectors' not in TestParams):
			self.TestParams['TargetSectors'] = 65536
						
		self.target_sectors = TestParams['TargetSectors']

	def WriteDataToDisk(self, root_dir, total_sectors, random_seed):			
		""" WriteDataToDisk
		
		Write data into the indicated root directory.
		The files/directories to write are generated by random. 
		
		"""
		self.Reset(random_seed)
		self.target_sectors = total_sectors
		test_gui.set_test_status(test_gui.TestStatus.WRITE_DATA)
		dir = root_dir
		depth = 0
		
		logging.info('Write files with sectors ' + str(total_sectors) + ' into volume ' + root_dir)
		
		while (self.target_reach() == False):
			self.FolderOperation(dir, True)
			dir += "\\" + str(self.folder_name)
			self.folder_name = self.folder_name + 1
			++depth
			
			if (depth >= 32):
				dir = root_dir
				depth = 0											
		
	def ReadDataFromDisk(self, root_dir, total_sectors, random_seed):			
		""" WriteDataToDisk
		
		Read data from the indicated root directory. 
		The files/directories to check are generated by random and will 
		be the same with WriteDataToDisk() if the seed is the same.
		
		"""		
		self.Reset(random_seed)
		self.target_sectors = total_sectors
		test_gui.set_test_status(test_gui.TestStatus.VERIFY_DATA)
		dir = root_dir
		depth = 0
		
		logging.info('Read files with sectors ' + str(total_sectors) + ' into volume ' + root_dir)
		
		while (self.target_reach() == False):
			self.FolderOperation(dir, False)
			dir += "\\" + str(self.folder_name)
			self.folder_name = self.folder_name + 1
			++depth
			
			if (depth >= 32):
				dir = root_dir
				depth = 0										
						
	def Reset(self, random_seed):
		logging.info(' *Reset random seed: ' + str(random_seed))
		self.written_sectors = 0
		self.folder_name = 0
		random.seed(random_seed)				
		self.file_names = []
							
	def FolderOperation(self, Folder, Write):
		""" Folder Operation
		
		Write or read files into/from the folder that indicated by the input argument.
		
		"""				
		logging.info(' Folder operation ' + Folder)
	
		self.file_names = []
		file_count = random.randrange(128, 255)
		
		if (Write and (os.path.exists(Folder) == False)):
			os.makedirs(Folder)
		
		for count in range(file_count):
			if (self.target_reach()):
				break
			
			path = Folder + "\\" + self.GetUnduplicatedFileName()		
					
			fsize = self.GetRandomFileSize()		
			
			if (Write):
				logging.info(' Write path ' + path + ' with file size ' + str(fsize) + ' sectors')
				self.WriteFile(path, fsize)
			else:
				logging.info(' Read path ' + path + ' with file size ' + str(fsize) + ' sectors')
				self.ReadFile(path, fsize)
			
			if (self.target_sectors != 0):
				#TODO: set progress
				pass					
	
	def WriteFile(self, FileName, SectorCount):
		""" Write File
		
		Actually write the file of the input Path with the input SectorCount.
		
		"""				
		chunk_cnt = 4096
		remain = SectorCount
		
		if (self.TestParams['CheckLastError']):
			self.written_sectors += SectorCount
			self.global_written_sectors += SectorCount
			return 0
		
		f = open(FileName, 'wb')
		sub_seed = random.randrange(0, 0xffffffff)
		
		while (remain != 0):
			if (self.target_reach()):
				break
			
			if (chunk_cnt > remain):
				chunk_cnt = remain
				
			pat = pattern.make(chunk_cnt * 512, 'random', sub_seed)
			sub_seed = sub_seed + 1				
						
			written = f.write(pat)
						
			self.written_sectors += written
			self.global_written_sectors += written			
						
			remain -= (written / 512)
			
		f.close()	
		
	def ReadFile(self, FileName, SectorCount):
		""" Read File
		
		Actually write the file of the input Path with the input SectorCount.
		
		"""				
		chunk_cnt = 4096
		remain = SectorCount
		
		if (self.TestParams['CheckLastError']):
			self.written_sectors += SectorCount
			self.global_written_sectors += SectorCount
			return 0
		
		f = open(FileName, 'rb')
		sub_seed = random.randrange(0, 0xffffffff)
		
		while (remain != 0):
			if (self.target_reach()):
				break
			
			if (chunk_cnt > remain):
				chunk_cnt = remain
				
			pat = pattern.make(chunk_cnt * 512, 'random', sub_seed)
			sub_seed = sub_seed + 1				
						
			res = f.read()
			
			if (res != pat):
				raise('pattern compared error!')
						
			readed = len(res)
						
			self.written_sectors += readed
			self.global_written_sectors += readed
												
			remain -= (readed / 512)
			
		f.close()			

	def GetRandomFileSize(self):
		sectors = random.randrange(self.TestParams['MinSectorCnt'], self.TestParams['MaxSectorCnt'])
		
		if ((sectors + self.written_sectors) > self.target_sectors):
			sectors = self.target_sectors - self.written_sectors
			
		return sectors
	
	def GetUnduplicatedFileName(self):
		while(True):
			res = str(random.randrange(0, 0x7fffffff))
			if (res in self.file_names) == False:
				self.file_names.append(res)
				return res
		
	def target_reach(self):
		return self.written_sectors >= self.target_sectors
		